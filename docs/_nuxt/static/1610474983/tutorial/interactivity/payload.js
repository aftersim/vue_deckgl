__NUXT_JSONP__("/tutorial/interactivity", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z){return {data:[{document:{slug:"interactivity",title:"Interacting with DeckGL",description:"how to interact with DeckGL",position:9,category:"Tutorial",version:1.4,fullscreen:false,menuTitle:"Interactivity",toc:[{id:x,depth:u,text:s},{id:v,depth:u,text:w}],body:{type:"root",children:[{type:b,tag:y,props:{id:x},children:[{type:b,tag:g,props:{href:"#interactivity-with-deckgl",ariaHidden:l,tabIndex:j},children:[{type:b,tag:i,props:{className:[k,m]},children:[]}]},{type:a,value:s}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"Interactivity comes in a couple different forms with DeckGL. "}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Controll the Viewport: "},{type:b,tag:d,props:{},children:[{type:a,value:":controller=\"true\" :controlMap=\"true\" "}]},{type:a,value:" ship by default, but these properties enable DeckGL\u002FMapbox to respond to viewState changes via mouse drag, scroll,etc."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:y,props:{id:v},children:[{type:b,tag:g,props:{href:"#interacting-with-onhover-and-adding-tooltips",ariaHidden:l,tabIndex:j},children:[{type:b,tag:i,props:{className:[k,m]},children:[]}]},{type:a,value:w}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"With DeckGL we can hook into either DeckGL's getTooltip event or a Layer's individual onHover event. Both callbacks look effectively the same. "}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"DeckGL: "},{type:b,tag:d,props:{},children:[{type:a,value:":getTooltip=\"CALLBACK"}]}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Layer: "},{type:b,tag:d,props:{},children:[{type:a,value:":onHover=\"CALLBACK\""}]}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"DeckGL provides two options as you may want to handle a individual type of Layers onHover differently. Like rendering different tooltips."}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"A tooltip in this case is just a HTML element that we render in our templates using a "},{type:b,tag:d,props:{},children:[{type:a,value:"v-if"}]},{type:a,value:t}]},{type:a,value:c},{type:b,tag:n,props:{className:[o]},children:[{type:b,tag:p,props:{className:[q,r]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"\u003Ctemplate\u003E \n  \u003CDeckGL\n  :getTooltip=\"deckToolTipCallback\n  \u003E\n  \u003C\u002FDeckGL\u003E\n...\n  \u003Cdiv id=\"example-deck-tooltip\" v-if=\"deckTooltipHovered\" :style=\"hoverPosition\"\u003E\n      \u003Cp\u003EvaluePerSqm: {{deckHoveredData.valuePerSqm}}\u003C\u002Fp\u003E\n      \u003Cp\u003EGrowth: {{deckHoveredData.growth}}\u003C\u002Fp\u003E\n  \u003C\u002Fdiv\u003E\n...\n\u003C\u002Ftemplate\u003E\n\n\u003Cscript\u003E\ndata:{\n  return {\n    ...\n    deckTooltipHovered: false,\n    deckHoveredData: {x:0, y:0, valuePerSqm: 0, growth:0}\n  }\n},\ncomputed: {\n      hoverPosition: function () {\n        return {\n            'position': 'absolute',\n            'left': (this.deckHoveredData.x + 30) + 'px',\n            'top': (this.deckHoveredData.y + + 30) + 'px'\n        }\n    }\n},\nmethods: {\n  deckTooltipCallback({x,y, picked, object}){\n      if(!(picked)){\n          this.deckTooltipHovered = false\n          return \n      }\n      \n      this.deckTooltipHovered = true\n      this.deckHoveredData.x = x\n      this.deckHoveredData.y = y\n      this.deckHoveredData.valuePerSqm = object.properties.valuePerSqm\n      this.deckHoveredData.growth = object.properties.growth\n  },\n}\n\u003C\u002Fscript\u003E\n\u003Cstyle scoped\u003E\n    #example-deck-tooltip{\n        position:absolute;\n        background-color:purple;\n        width:10%;\n        height:10%;\n    }\n\u003C\u002Fstyle\u003E\n"}]}]}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"We implement a tooltip by doing the following"}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Create a HTML element that will hold data that we conditionally render and provide style to."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Create data for Vue to be reactive on. "}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Generate a computed style property that will render the Tooltip in the location of the values that come back from the Hover event."}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Create a callback for getTooltip that destructures that data provided. "}]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"Create some default styling for a tooltip that won't change."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"To implement this at a Layer level, we would only need to change the following:"}]},{type:a,value:c},{type:b,tag:n,props:{className:[o]},children:[{type:b,tag:p,props:{className:[q,r]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"\u003Ctemplate\u003E \n  \u003CDeckGL\n  \u003E\n  ...\n  \u003CGeoJsonLayer \n    onHover=\"deckTooltipCallback\"\n  \u002F\u003E\n  \u003C\u002FDeckGL\u003E\n...\n  \u003Cdiv id=\"example-deck-tooltip\" v-if=\"deckTooltipHovered\" :style=\"hoverPosition\"\u003E\n      \u003Cp\u003EvaluePerSqm: {{deckHoveredData.valuePerSqm}}\u003C\u002Fp\u003E\n      \u003Cp\u003EGrowth: {{deckHoveredData.growth}}\u003C\u002Fp\u003E\n  \u003C\u002Fdiv\u003E\n...\n\u003C\u002Ftemplate\u003E\n"}]}]}]},{type:a,value:c},{type:b,tag:"h4",props:{id:"advanced-picking-objects"},children:[{type:b,tag:g,props:{href:"#advanced-picking-objects",ariaHidden:l,tabIndex:j},children:[{type:b,tag:i,props:{className:[k,m]},children:[]}]},{type:a,value:"Advanced: Picking Objects"}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"We have also exposed the picking engine of DeckGL through a public facing API which you can access by a "},{type:b,tag:d,props:{},children:[{type:a,value:"ref"}]},{type:a,value:" on the DeckGL component. "}]},{type:a,value:c},{type:b,tag:n,props:{className:[o]},children:[{type:b,tag:p,props:{className:[q,r]},children:[{type:b,tag:d,props:{},children:[{type:a,value:"\u003Ctemplate\u003E\n    ...\n  \u003CDeckGL ref=\"deck\"\u003E\u003C\u002FDeckGL\u003E\n    ...\n\u003C\u002Ftemplate\u003E\n\n\u003Cscript\u003E\n\n...\nmounted(){\n    this.$refs.deck.pickObject(100, 100, 0, null, false)\n}\n...\n"}]}]}]},{type:a,value:c},{type:b,tag:h,props:{},children:[{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"If you had a "},{type:b,tag:d,props:{},children:[{type:a,value:"pickable: true"}]},{type:a,value:" layer in that location, it would return back the the object in that position."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:f,props:{},children:[{type:a,value:"For full details, "},{type:b,tag:g,props:{href:"https:\u002F\u002Fdeck.gl\u002Fdocs\u002Fdeveloper-guide\u002Finteractivity",rel:["nofollow","noopener","noreferrer"],target:"_blank"},children:[{type:a,value:"see the docs"}]},{type:a,value:t}]}]},dir:"\u002Fen\u002Ftutorial",path:"\u002Fen\u002Ftutorial\u002Finteractivity",extension:".md",createdAt:z,updatedAt:z,to:"\u002Ftutorial\u002Finteractivity"},prev:{slug:"layers",title:"Adding Data with Layers",to:"\u002Ftutorial\u002Flayers"},next:{slug:"lifecycle",title:"Lifecycle Events of DeckGL",to:"\u002Ftutorial\u002Flifecycle"}}],fetch:[],mutations:[]}}("text","element","\n","code","li","p","a","ul","span",-1,"icon","true","icon-link","div","nuxt-content-highlight","pre","language-text","line-numbers","Interactivity with DeckGL",".",3,"interacting-with-onhover-and-adding-tooltips","Interacting with onHover and adding Tooltips","interactivity-with-deckgl","h3","2021-01-12T18:09:05.129Z")));